<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Set</title>
  <script>
    //** Set (Object)
    //: new 키워드로 생성
    //: 고유한 값의 집합(Collection)
    //: 중복된 값을 허용하지 않고, 유일한 값을 효과적 관리
    //: 모든 데이터 타입을 저장

    //Set 생성
    const testSet = new Set();

    console.log(typeof testSet);
    console.log(testSet);

    //초기값을 포함한 Set 생성
    const mySet = new Set([1, '2', 3])
    console.log(mySet); //{1, '2', 3}

    //Set에 값 추가 => add()
    mySet.add(4)
    console.log(mySet); //{1, '2', 3, 4}

    mySet.add(1) //중복값을 허용하지 않기 때문에 추가되지 않음
    console.log(mySet); //{1, '2', 3, 4}

    mySet.add(2)
    console.log(mySet); //{1, '2', 3, 4, 2}

    mySet.add(true).add(10 < 5); //메소드 체이닝도 가능
    console.log(mySet); //{1, '2', 3, 4, 2, true, false}(7)

    console.log(mySet[1]);
    //값이 추가된 순서대로 저장이 되긴 하지만,
    //배열처럼 인덱스를 통한 접근 불가

    //값 삭제 => delete()
    mySet.delete(false)
    mySet.delete('2')
    console.log(mySet) //{1, 3, 4, 2, true}(5)

    mySet.delete(3) //delete는 체이닝 불가
    console.log(mySet);//{1, 4, 2, true}(4)

    mySet.delete(5)
    console.log(mySet);//{1, 4, 2, true}(4)

    console.log(mySet.add(3)); //add의 결과를 콘솔에 출력

    console.log(mySet.delete(3)); //true
    console.log(mySet.delete(5)); //false

    //mySet에서 1을 삭제한 결과를 저장
    let data = 1
    // let data = prompt('삭제하려는 데이터를 입력')
    let result = mySet.delete(data)
    if(result) console.log('삭제 성공');
    else console.log('삭제할 데이터 없음');

    //Set에 포함된 데이터의 갯수
    console.log(mySet.size);

    //Set에 포함된 데이터 확인
    console.log(mySet.has(2)); //true
    console.log(mySet.has(5)); //false

    //clear() => Set의 모든 데이터 삭제
    // console.log(mySet.clear());
    mySet.clear()
    console.log(mySet);

    const fruits = ['banana', 'mango', 'grape', 'banana', 'apple', 'kiwi']
    const numbers = [1,1,2,3,4,4,4,4,5,5,6,6,6,6,6,7,8,9,9]

    const set1 = new Set(['dog', 'cat', 'cat', 'rabbit', 'dog'])
    console.log(set1.size, set1); //3

    const set2 = new Set(fruits)
    console.log(set2.size, set2); //5

    const set3 = new Set(numbers)
    console.log(set3.size, set3); //9

    //set1과 set2 합쳐서 하나의 배열
    const mergeArr = [...set1, ...set2]
    console.log(mergeArr.length); //8

    //중복값이 많이 numbers 배열에 중복값을 삭제하고 다시 배열로 저장
    const newNumbers = [...new Set(numbers)]
    console.log(newNumbers[4]);  //5

    console.group('Set')
    console.log('set1 : ', ...set1);
    console.log('set2 : ', ...set2);
    console.log('set3 : ', ...set3);
    console.groupEnd()

    console.group('Set1 => forEach')
    set1.forEach(item => {
      console.log(item);
    })
    console.groupEnd()

    console.group('Set2 => forEach')
    for(item of set2) {
      console.log(item);
    }
    console.groupEnd()

    console.group('Set3 => map')
    // console.log(set3.find(item => item > 2));
    // map(), filter(), find(), ... 은 불가
    console.groupEnd()

    console.group('Array');
    const arr1 = [1, '2', 3]
    console.log(arr1);
    arr1.push(1)
    console.log(arr1, arr1[1]);
    arr1.unshift(1)
    console.log(arr1, arr1[1]);
    console.groupEnd()

    console.group('** Quiz **')
    const q1 = new Set(['a', 'b', 'c', 'd', 'e', 'f'])
    const q2 = new Set(['d', 'e', 'f', 'g', 'h', 'i'])
    // 합집합
    const unite = [...q1, ...q2]
    console.log(unite);

    //교집합 => 공통
    const intersection = [...q1].filter(item => q2.has(item))
    console.log(intersection); //['d', 'e', 'f']

    //q1에 대한 q2의 차집합
    const different = [...q1].filter(item => !q2.has(item))
    console.log(different); //['a', 'b', 'c']

    console.groupEnd()

  </script>
</head>
<body>

</body>
</html>